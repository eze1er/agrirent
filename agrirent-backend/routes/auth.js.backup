const express = require("express");
const router = express.Router();
const jwt = require("jsonwebtoken");
const crypto = require("crypto");
const passport = require('passport');
require('../middleware/config/passport'); // Load config
const User = require("../models/User");
const {
  sendWelcomeEmail,
  sendVerificationEmail,
  sendPasswordResetEmail,
} = require("../services/emailService");
const {
  sendVerificationSMS,
  generateVerificationCode,
} = require("../services/smsService");

const smsSendLocks = new Map();

// Validation helper
const validateEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

const validatePassword = (password) => {
  return password && password.length >= 6;
};

const validatePhoneNumber = (phone) => {
  if (!phone) return true; // Phone is optional

  const phoneRegex = /^\+[1-9]\d{1,14}$/;
  return phoneRegex.test(phone);
};

// ============================================
// DEBUG ROUTES (Remove in production!)
// ============================================

// Debug: List all users
router.get("/debug/users", async (req, res) => {
  try {
    const users = await User.find({}).select(
      "email firstName lastName role isEmailVerified"
    );
    res.json({
      success: true,
      count: users.length,
      users,
    });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

// Debug: Reset password (bypass token)
router.post("/debug/reset-password", async (req, res) => {
  try {
    const { email, newPassword } = req.body;

    if (!email || !newPassword) {
      return res.status(400).json({
        success: false,
        message: "Email and new password are required",
      });
    }

    if (!validatePassword(newPassword)) {
      return res.status(400).json({
        success: false,
        message: "Password must be at least 6 characters",
      });
    }

    const user = await User.findOne({ email: email.toLowerCase() });
    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }

    user.password = newPassword;
    await user.save(); // This will auto-hash the password

    res.json({
      success: true,
      message: "Password reset successfully",
      user: {
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
      },
    });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

// Debug: Verify email (bypass token)
router.post("/debug/verify-me", async (req, res) => {
  try {
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({
        success: false,
        message: "Email is required",
      });
    }

    const user = await User.findOneAndUpdate(
      { email: email.toLowerCase() },
      { isEmailVerified: true },
      { new: true }
    ).select("-password");

    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }

    res.json({
      success: true,
      message: "Email verified successfully!",
      user: {
        email: user.email,
        firstName: user.firstName,
        isEmailVerified: user.isEmailVerified,
      },
    });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

// Debug: Delete user
router.delete("/debug/delete-user", async (req, res) => {
  try {
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({
        success: false,
        message: "Email is required",
      });
    }

    const user = await User.findOneAndDelete({ email: email.toLowerCase() });

    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }

    res.json({
      success: true,
      message: "User deleted successfully",
      deletedUser: {
        email: user.email,
        firstName: user.firstName,
      },
    });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

// routes/auth.js - Add this debug route

router.get("/debug/check-phone", async (req, res) => {
  try {
    const { email } = req.query;

    const user = await User.findOne({ email: email.toLowerCase() }).select(
      "firstName lastName email phone"
    );

    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }

    res.json({
      success: true,
      user: {
        name: `${user.firstName} ${user.lastName}`,
        email: user.email,
        phone: user.phone || "NO PHONE NUMBER",
        hasPhone: !!user.phone,
      },
    });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

// Add route to update phone number
router.post("/debug/update-phone", async (req, res) => {
  try {
    const { email, phone } = req.body;

    if (!email || !phone) {
      return res.status(400).json({
        success: false,
        message: "Email and phone are required",
      });
    }

    const user = await User.findOneAndUpdate(
      { email: email.toLowerCase() },
      { phone },
      { new: true }
    ).select("-password");

    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }

    res.json({
      success: true,
      message: "Phone number updated successfully",
      user: {
        email: user.email,
        phone: user.phone,
      },
    });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

// ============================================
// REGULAR AUTH ROUTES
// ============================================

router.post('/register', async (req, res) => {
  try {
    const { firstName, lastName, email, password, phone, role } = req.body;

    // Validation
    if (!firstName || !lastName || !email || !password) {
      return res.status(400).json({
        success: false,
        message: 'Please provide firstName, lastName, email, and password'
      });
    }

    if (password.length < 6) {
      return res.status(400).json({
        success: false,
        message: 'Password must be at least 6 characters'
      });
    }

    // Check if user already exists
    const existingUser = await User.findOne({ email: email.toLowerCase() });
    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'Email already registered. Please login instead.'
      });
    }

    // ‚úÖ FIX: Create user WITHOUT manual hashing
    // The User model's pre-save hook will hash the password automatically
    const user = await User.create({
      firstName: firstName.trim(),
      lastName: lastName.trim(),
      email: email.toLowerCase().trim(),
      password: password, // ‚úÖ Pass plain password - model will hash it
      phone: phone?.trim() || '',
      role: role || 'renter',
      isEmailVerified: false
    });

    console.log('‚úÖ User created successfully:', user.email);

    // Generate JWT token
    const token = jwt.sign(
      { userId: user._id, email: user.email, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );

    res.status(201).json({
      success: true,
      message: 'Registration successful',
      token,
      user: {
        _id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        phone: user.phone,
        role: user.role,
        isEmailVerified: user.isEmailVerified,
        isPhoneVerified: user.isPhoneVerified
      }
    });

  } catch (error) {
    console.error('‚ùå Registration error:', error);
    
    // Handle specific MongoDB errors
    if (error.code === 11000) {
      const field = Object.keys(error.keyPattern)[0];
      return res.status(400).json({
        success: false,
        message: `${field.charAt(0).toUpperCase() + field.slice(1)} already exists`
      });
    }

    // Handle validation errors
    if (error.name === 'ValidationError') {
      const messages = Object.values(error.errors).map(err => err.message);
      return res.status(400).json({
        success: false,
        message: messages.join(', ')
      });
    }

    res.status(500).json({
      success: false,
      message: 'Registration failed. Please try again.',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// ============================================
// LOGIN ROUTE - Should already be working
// ============================================
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    // Validation
    if (!email || !password) {
      return res.status(400).json({
        success: false,
        message: 'Email and password are required'
      });
    }

    // Find user and select password field (it's not selected by default)
    const user = await User.findOne({ email: email.toLowerCase() }).select('+password');

    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }

    // ‚úÖ Compare plain password with hashed password
    const isPasswordCorrect = await user.comparePassword(password);

    if (!isPasswordCorrect) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }

    // Generate JWT token
    const token = jwt.sign(
      { userId: user._id, email: user.email, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );

    console.log('‚úÖ Login successful:', user.email);

    res.json({
      success: true,
      message: 'Login successful',
      token,
      user: {
        _id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        phone: user.phone,
        role: user.role,
        isEmailVerified: user.isEmailVerified,
        isPhoneVerified: user.isPhoneVerified
      }
    });

  } catch (error) {
    console.error('‚ùå Login error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error. Please try again.',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

module.exports = router;

// Traditional email/password login
// Traditional email/password login
router.post("/login", async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({
        success: false,
        message: "Email and password are required",
      });
    }

    const user = await User.findOne({ email: email.toLowerCase() }).select(
      "+password"
    );

    if (!user) {
      console.log("‚ùå User not found:", email);
      return res.status(401).json({
        success: false,
        message: "Invalid credentials",
      });
    }

    const isPasswordValid = await user.comparePassword(password);
    if (!isPasswordValid) {
      console.log("‚ùå Password mismatch for:", email);
      return res.status(401).json({
        success: false,
        message: "Invalid credentials",
      });
    }

    // ‚úÖ CHECK BYPASS MODE
    const bypassVerification = process.env.BYPASS_PHONE_VERIFICATION === "true";

    // Skip phone verification for admin OR if bypass mode is on
    if (user.role === "admin" || bypassVerification) {
      console.log("‚úÖ Login successful (verification bypassed):", email);

      const token = jwt.sign(
        { id: user._id, role: user.role },
        process.env.JWT_SECRET,
        { expiresIn: "7d" }
      );

      return res.json({
        success: true,
        token,
        user: {
          id: user._id,
          firstName: user.firstName,
          lastName: user.lastName,
          email: user.email,
          phone: user.phone,
          role: user.role,
          isPhoneVerified: true, // Force true
        },
        requiresVerification: false,
      });
    }

    // Check if phone is verified (only when NOT bypassing)
    if (!user.isPhoneVerified) {
      console.log("‚ö†Ô∏è User phone not verified:", email);
      return res.json({
        success: true,
        token: jwt.sign(
          { id: user._id, role: user.role },
          process.env.JWT_SECRET,
          { expiresIn: "7d" }
        ),
        user: {
          id: user._id,
          firstName: user.firstName,
          lastName: user.lastName,
          email: user.email,
          phone: user.phone,
          role: user.role,
          isPhoneVerified: user.isPhoneVerified,
        },
        requiresVerification: true,
        message: "Please verify your phone number to continue",
      });
    }

    console.log("‚úÖ Login successful:", email);

    const token = jwt.sign(
      { id: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: "7d" }
    );

    res.json({
      success: true,
      token,
      user: {
        id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        phone: user.phone,
        role: user.role,
        isPhoneVerified: user.isPhoneVerified,
      },
      requiresVerification: false,
    });
  } catch (error) {
    console.error("Login error:", error);
    res.status(500).json({
      success: false,
      message: "Login failed. Please try again.",
    });
  }
});

// Resend verification email
router.post("/resend-verification", async (req, res) => {
  try {
    const { email } = req.body;

    console.log("üìß Resend verification request for:", email);

    if (!email) {
      return res.status(400).json({
        success: false,
        message: "Email is required",
      });
    }

    const user = await User.findOne({ email: email.toLowerCase() });

    if (!user) {
      console.log("‚ùå User not found:", email);
      return res.status(404).json({
        success: false,
        message: "No account found with this email",
      });
    }

    console.log("üìä User verification status:", {
      email: user.email,
      isEmailVerified: user.isEmailVerified,
      hasToken: !!user.emailVerificationToken,
    });

    // ‚úÖ CRITICAL: Check verification status FIRST
    if (user.isEmailVerified) {
      console.log("‚úÖ Email already verified for:", user.email);
      return res.json({
        success: true,
        alreadyVerified: true,
        message: "Your email is already verified!",
      });
    }

    // Generate NEW verification token
    const verificationToken = crypto.randomBytes(32).toString("hex");
    user.emailVerificationToken = verificationToken;
    user.emailVerificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 hours
    await user.save();

    console.log("üîë New verification token generated for:", user.email);

    // Send verification email
    try {
      await sendVerificationEmail(user, verificationToken);
      console.log("‚úÖ Verification email sent to:", user.email);
    } catch (emailError) {
      console.error("‚ùå Failed to send verification email:", emailError);
      return res.status(500).json({
        success: false,
        message: "Failed to send verification email. Please try again.",
      });
    }

    res.json({
      success: true,
      alreadyVerified: false,
      message: "Verification email sent! Please check your inbox.",
    });
  } catch (error) {
    console.error("‚ùå Resend verification error:", error);
    res.status(500).json({
      success: false,
      message: "Failed to resend verification email",
    });
  }
});

// Email verification endpoint
router.get("/verify-email/:token", async (req, res) => {
  try {
    const { token } = req.params;

    console.log(
      "üîç Email verification attempt with token:",
      token.substring(0, 10) + "..."
    );

    // Find user with valid verification token
    const user = await User.findOne({
      emailVerificationToken: token,
      emailVerificationExpires: { $gt: Date.now() },
    });

    if (!user) {
      console.log("‚ùå Invalid or expired verification token");
      // Redirect to frontend with error - DON'T include email to prevent loops
      return res.redirect(
        `${process.env.FRONTEND_URL}/verify-email?verified=false&error=invalid_token`
      );
    }

    console.log(
      "‚úÖ Valid token found for user:",
      user.email,
      "Current verified status:",
      user.isEmailVerified
    );

    // ‚úÖ CRITICAL: Only update if not already verified
    if (!user.isEmailVerified) {
      user.isEmailVerified = true;
      user.emailVerificationToken = undefined;
      user.emailVerificationExpires = undefined;
      await user.save();
      console.log("‚úÖ User email marked as verified:", user.email);
    } else {
      console.log("‚ÑπÔ∏è Email already verified for:", user.email);
    }

    // ‚úÖ CRITICAL: Generate a proper JWT token for immediate login
    const loginToken = jwt.sign(
      { id: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: "7d" }
    );

    // ‚úÖ CRITICAL: Redirect to dashboard with token for immediate access
    res.redirect(
      `${
        process.env.FRONTEND_URL
      }/verify-email?verified=true&email=${encodeURIComponent(
        user.email
      )}&token=${loginToken}&userId=${user._id}`
    );
  } catch (error) {
    console.error("‚ùå Email verification error:", error);
    res.redirect(
      `${process.env.FRONTEND_URL}/verify-email?verified=false&error=server_error`
    );
  }
});
// Forgot password
router.post("/forgot-password", async (req, res) => {
  try {
    const { email } = req.body;

    if (!email || !validateEmail(email)) {
      return res.status(400).json({
        success: false,
        message: "Valid email is required",
      });
    }

    const user = await User.findOne({ email: email.toLowerCase() });

    if (!user) {
      return res.json({
        success: true,
        message: "If an account exists, a reset link has been sent",
      });
    }

    const resetToken = crypto.randomBytes(32).toString("hex");
    user.passwordResetToken = resetToken;
    user.passwordResetExpires = Date.now() + 60 * 60 * 1000;
    await user.save();

    try {
      await sendPasswordResetEmail(user, resetToken);
    } catch (emailError) {
      console.error("Failed to send password reset email:", emailError);
    }

    res.json({
      success: true,
      message: "If an account exists, a reset link has been sent",
    });
  } catch (error) {
    console.error("Forgot password error:", error);
    res.status(500).json({
      success: false,
      message: "Failed to process request",
    });
  }
});
// Reset password
router.post("/reset-password/:token", async (req, res) => {
  try {
    const { token } = req.params;
    const { password } = req.body;

    if (!validatePassword(password)) {
      return res.status(400).json({
        success: false,
        message: "Password must be at least 6 characters",
      });
    }

    const user = await User.findOne({
      passwordResetToken: token,
      passwordResetExpires: { $gt: Date.now() },
    });

    if (!user) {
      return res.status(400).json({
        success: false,
        message: "Invalid or expired reset token",
      });
    }

    user.password = password;
    user.passwordResetToken = undefined;
    user.passwordResetExpires = undefined;
    await user.save();

    res.json({
      success: true,
      message: "Password reset successfully",
    });
  } catch (error) {
    console.error("Reset password error:", error);
    res.status(500).json({
      success: false,
      message: "Failed to reset password",
    });
  }
});

// ============================================
// SMS VERIFICATION ROUTES
// ============================================

// Send SMS verification code
router.post("/send-sms-verification", async (req, res) => {
  const requestId = Math.random().toString(36).substring(7);
  console.log(`\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`);
  console.log(`üì± [${requestId}] SMS REQUEST STARTED`);
  console.log(`üì± [${requestId}] Email:`, req.body.email);
  console.log(`üì± [${requestId}] Phone:`, req.body.phone);
  console.log(`üì± [${requestId}] Time:`, new Date().toISOString());

  try {
    const { email, phone } = req.body;

    if (!phone) {
      console.log(`‚ùå [${requestId}] No phone provided`);
      return res.status(400).json({
        success: false,
        message: "Phone number is required",
      });
    }

    // CHECK LOCK
    const lockKey = phone;
    console.log(`üîí [${requestId}] Checking lock for:`, lockKey);
    console.log(`üîí [${requestId}] Lock exists?`, smsSendLocks.has(lockKey));

    if (smsSendLocks.has(lockKey)) {
      console.log(`‚õî [${requestId}] BLOCKED - Lock exists!`);
      console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`);
      return res.json({
        success: true,
        message: "Verification code is being sent. Please wait...",
        expiresIn: "10 minutes",
      });
    }

    // SET LOCK
    console.log(`üîí [${requestId}] Setting lock for:`, lockKey);
    smsSendLocks.set(lockKey, true);
    console.log(
      `üîí [${requestId}] Lock set. Current locks:`,
      Array.from(smsSendLocks.keys())
    );

    setTimeout(() => {
      console.log(`üîì [${requestId}] Removing lock for:`, lockKey);
      smsSendLocks.delete(lockKey);
    }, 5000);

    console.log(`üîç [${requestId}] Finding user...`);
    const user = await User.findOne({
      $or: [{ email: email?.toLowerCase() }, { phone }],
    });

    if (!user) {
      console.log(`‚ùå [${requestId}] User not found`);
      smsSendLocks.delete(lockKey);
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    console.log(`‚úÖ [${requestId}] User found:`, user.email);
    console.log(`üìã [${requestId}] User verified?`, user.isPhoneVerified);
    console.log(`üìã [${requestId}] Has code?`, !!user.phoneVerificationCode);
    console.log(
      `üìã [${requestId}] Code expires:`,
      user.phoneVerificationExpires
    );
    console.log(`üìã [${requestId}] Attempts:`, user.phoneVerificationAttempts);

    if (user.isPhoneVerified) {
      console.log(`‚úÖ [${requestId}] Already verified - skipping`);
      smsSendLocks.delete(lockKey);
      return res.json({
        success: true,
        alreadyVerified: true,
        message: "Phone number is already verified",
      });
    }

    // CHECK IF CODE EXISTS
    const hasValidCode =
      user.phoneVerificationCode &&
      user.phoneVerificationExpires &&
      user.phoneVerificationExpires > Date.now();

    console.log(`üìã [${requestId}] Has valid code?`, hasValidCode);

    let code;

    if (hasValidCode) {
      console.log(`‚ôªÔ∏è [${requestId}] REUSING existing code`);
      code = user.phoneVerificationCode;
    } else {
      console.log(`üÜï [${requestId}] GENERATING new code`);

      // Rate limiting check
      if (user.phoneVerificationAttempts >= 5) {
        const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
        const lastExpiry = user.phoneVerificationExpires || new Date(0);

        if (lastExpiry > oneHourAgo) {
          console.log(`‚õî [${requestId}] Rate limit exceeded`);
          smsSendLocks.delete(lockKey);
          return res.status(429).json({
            success: false,
            message: "Too many verification attempts. Please try again later.",
          });
        }
        user.phoneVerificationAttempts = 0;
      }

      const { generateVerificationCode } = require("../services/smsService");
      code = generateVerificationCode();
      user.phoneVerificationCode = code;
      user.phoneVerificationExpires = Date.now() + 10 * 60 * 1000;
      user.phoneVerificationAttempts += 1;
      await user.save();
      console.log(
        `üíæ [${requestId}] Code saved. Attempts now:`,
        user.phoneVerificationAttempts
      );
    }

    // SEND SMS
    console.log(`üì§ [${requestId}] Attempting to send SMS...`);
    console.log(`üì§ [${requestId}] To:`, user.phone);
    console.log(`üì§ [${requestId}] Code:`, code);

    try {
      const { sendVerificationSMS } = require("../services/smsService");
      await sendVerificationSMS(user.phone, code, user.firstName);

      console.log(`‚úÖ [${requestId}] SMS SENT SUCCESSFULLY!`);
      console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`);

      res.json({
        success: true,
        message: "Verification code sent to your phone",
        expiresIn: "10 minutes",
      });
    } catch (smsError) {
      console.error(`‚ùå [${requestId}] SMS send failed:`, smsError.message);
      smsSendLocks.delete(lockKey);
      console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`);
      return res.status(500).json({
        success: false,
        message: "Failed to send SMS. Please check your phone number.",
      });
    }
  } catch (error) {
    console.error(`‚ùå [${requestId}] ERROR:`, error);
    if (req.body.phone) {
      smsSendLocks.delete(req.body.phone);
    }
    console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`);
    res.status(500).json({
      success: false,
      message: "Failed to send verification code",
    });
  }
});

// Verify SMS code
router.post("/verify-sms-code", async (req, res) => {
  try {
    const { email, phone, code } = req.body;

    console.log("üîç SMS code verification attempt:", { email, phone, code });

    if (!code) {
      return res.status(400).json({
        success: false,
        message: "Verification code is required",
      });
    }

    // Find user
    const user = await User.findOne({
      $or: [{ email: email?.toLowerCase() }, { phone }],
    });

    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // Check if already verified
    if (user.isPhoneVerified) {
      return res.json({
        success: true,
        alreadyVerified: true,
        message: "Phone number is already verified",
      });
    }

    // Check if code exists
    if (!user.phoneVerificationCode) {
      return res.status(400).json({
        success: false,
        message: "No verification code found. Please request a new one.",
      });
    }

    // Check if code expired
    if (user.phoneVerificationExpires < Date.now()) {
      return res.status(400).json({
        success: false,
        message: "Verification code expired. Please request a new one.",
      });
    }

    // Verify code
    if (user.phoneVerificationCode !== code.trim()) {
      console.log(
        "‚ùå Invalid code. Expected:",
        user.phoneVerificationCode,
        "Got:",
        code
      );
      return res.status(400).json({
        success: false,
        message: "Invalid verification code",
      });
    }

    // ‚úÖ Mark phone AND overall account as verified
    user.isPhoneVerified = true;
    user.phoneVerificationCode = undefined;
    user.phoneVerificationExpires = undefined;
    user.phoneVerificationAttempts = 0;
    await user.save();

    console.log("‚úÖ Phone verified for:", user.email);

    // Generate new token with verified status
    const jwt = require("jsonwebtoken");
    const token = jwt.sign(
      { id: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: "7d" }
    );

    res.json({
      success: true,
      token,
      message: "Phone number verified successfully!",
      user: {
        id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        phone: user.phone,
        role: user.role,
        isPhoneVerified: user.isPhoneVerified,
      },
    });
  } catch (error) {
    console.error("‚ùå Verify SMS code error:", error);
    res.status(500).json({
      success: false,
      message: "Failed to verify code",
    });
  }
});
// Verify SMS code
// Traditional email/password registration - PHONE VERIFICATION ONLY
router.post("/register", async (req, res) => {
  try {
    const { firstName, lastName, email, password, phone, role } = req.body;

    console.log("üìù Registration attempt:", {
      firstName,
      lastName,
      email,
      hasPassword: !!password,
      phone,
      role,
    });

    // Validation
    if (!firstName || !lastName || !email || !password || !phone) {
      return res.status(400).json({
        success: false,
        message:
          "First name, last name, email, password, and phone number are required",
      });
    }

    if (!validateEmail(email)) {
      return res.status(400).json({
        success: false,
        message: "Invalid email format",
      });
    }

    if (!validatePassword(password)) {
      return res.status(400).json({
        success: false,
        message: "Password must be at least 6 characters",
      });
    }

    if (!validatePhoneNumber(phone)) {
      return res.status(400).json({
        success: false,
        message:
          "Invalid phone number format. Please use international format with country code (e.g., +12125551234)",
      });
    }

    const validRoles = ["renter", "owner", "both"];
    const userRole = role || "renter";
    if (!validRoles.includes(userRole)) {
      return res.status(400).json({
        success: false,
        message: "Invalid role. Must be renter, owner, or both",
      });
    }

    const existingUser = await User.findOne({ email: email.toLowerCase() });
    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: "User already exists with this email",
      });
    }

    // Generate SMS verification code
    const verificationCode = Math.floor(
      100000 + Math.random() * 900000
    ).toString();

    // Create user with phone verification code
    const user = await User.create({
      firstName: firstName.trim(),
      lastName: lastName.trim(),
      email: email.toLowerCase().trim(),
      password,
      phone: phone.trim(),
      role: userRole,
      isPhoneVerified: false,
      phoneVerificationCode: verificationCode,
      phoneVerificationExpires: Date.now() + 10 * 60 * 1000,
      phoneVerificationAttempts: 1, // Mark as code generated
    });

    console.log("‚úÖ User created:", user.email, "Phone:", user.phone);
    console.log("üìã Code generated but NOT sent. Frontend will send it.");

    // ‚úÖ DO NOT SEND SMS HERE!
    // Frontend will call /send-sms-verification which will reuse this code

    const token = jwt.sign(
      { id: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: "7d" }
    );

    res.status(201).json({
      success: true,
      token,
      user: {
        id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        phone: user.phone,
        role: user.role,
        isPhoneVerified: user.isPhoneVerified,
      },
      message: "Registration successful! Please verify your phone number.",
    });
  } catch (error) {
    console.error("‚ùå Registration error:", error);

    if (error.code === 11000) {
      return res.status(400).json({
        success: false,
        message: "User already exists with this email",
      });
    }

    if (error.name === "ValidationError") {
      const messages = Object.values(error.errors).map((e) => e.message);
      return res.status(400).json({
        success: false,
        message: messages.join(", "),
      });
    }

    res.status(500).json({
      success: false,
      message: "Registration failed. Please try again.",
      error: process.env.NODE_ENV === "development" ? error.message : undefined,
    });
  }
});

// Google OAuth routes
router.get(
  "/google",
  passport.authenticate("google", {
    scope: ["profile", "email"],
    session: false,
  })
);

// üîß FIX: Google callback should only allow EXISTING users, not create new ones

router.get('/google/callback', async (req, res) => {
  try {
    const { code } = req.query;

    if (!code) {
      return res.status(400).json({ success: false, message: 'No auth code provided' });
    }

    // Get Google tokens
    const { tokens } = await oauth2Client.getToken(code);
    oauth2Client.setCredentials(tokens);

    // Get user info from Google
    const response = await axios.get(
      'https://www.googleapis.com/oauth2/v2/userinfo',
      { headers: { Authorization: `Bearer ${tokens.access_token}` } }
    );

    const { email, name, picture } = response.data;
    console.log('üì• Google callback received for email:', email);

    // ‚úÖ FIX: ONLY LOGIN if user ALREADY EXISTS in database
    let user = await User.findOne({ email });

    // ‚ùå If user doesn't exist, redirect with error instead of creating new user
    if (!user) {
      console.log('‚ùå User not registered:', email);
      return res.redirect(
        `http://localhost:5173?error=user_not_found&email=${encodeURIComponent(email)}`
      );
    }

    // ‚úÖ User exists - update Google info if needed
    if (!user.googleId) {
      user.googleId = response.data.id;
      user.avatar = picture || user.avatar;
      await user.save();
      console.log('‚úÖ Linked Google account to existing user:', email);
    }

    // ‚úÖ Generate JWT token
    const token = jwt.sign(
      { userId: user._id, email: user.email },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );

    console.log('‚úÖ JWT token generated for:', email);

    // ‚úÖ Redirect with token and user data
    const userData = encodeURIComponent(
      JSON.stringify({
        _id: user._id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        phone: user.phone,
        role: user.role,
        avatar: user.avatar,
        isEmailVerified: user.isEmailVerified,
        isPhoneVerified: user.isPhoneVerified,
      })
    );

    res.redirect(
      `http://localhost:5173?token=${token}&user=${userData}`
    );

  } catch (error) {
    console.error('‚ùå Google callback error:', error.message);
    res.redirect('http://localhost:5173?error=auth_failed');
  }
});

  const handleGoogleLogin = () => {
    console.log('üîÑ Redirecting to Google OAuth...');
    window.location.href = 'http://localhost:3001/api/auth/google';
  };

module.exports = router;
